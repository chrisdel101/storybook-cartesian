{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  concat,\n  each,\n  filter,\n  find,\n  first,\n  flatMap,\n  fromPairs,\n  get,\n  isArray,\n  isEmpty,\n  keys,\n  map,\n  mapValues,\n  negate,\n  reduce,\n  toPairs,\n  values,\n  zip\n} from 'lodash/fp'\n\nimport flatten, { unflatten } from 'flat'\ninterface StoryVariant<T> {\n  props: T\n  story: any\n  title: string\n}\ntype CartesianData<T> = { [P in keyof T]: Array<T[P]> | any }\n\nconst titles = {\n  renderCheckSignsIfExists: ({\n    exists = 'âœ“',\n    missing = 'x',\n    existsFn = (v: any) => v,\n    sep = ' | '\n  } = {}) => (props: any) =>\n    toPairs(props)\n      .map(([k, v]) => (existsFn(v) ? `${exists} ${k}` : `${missing} ${k}`))\n      .join(sep),\n  renderPropNames: ({ sep = ' | ' } = {}) => (props: any) =>\n    keys(props).join(sep),\n  renderProps: ({ eqSep = '=', sep = ' ' } = {}) => (props: any) =>\n    toPairs(props)\n      .map(([k, v]) => `${k}${eqSep}${JSON.stringify(v)}`)\n      .join(sep)\n}\n// map props values, with legend lookup but also\n// treat nested structured by flatten->map->unflaten like:\n// { text: 'foo', colors: { bg: '1', fg: '2'}}\nconst renderWithLegend = (legend: any) => (f: any) => (props: any) =>\n  f(\n    unflatten(\n      mapValues(\n        (p: any) => legend[p != null ? p.toString() : 'null'] || p,\n        flatten(props)\n      )\n    )\n  )\n\nconst renderWithLegendFlat = (legend: any) => (f: any) => (props: any) =>\n  f(\n    mapValues((p: any) => legend[p != null ? p.toString() : 'null'] || p, props)\n  )\n\nconst xproduct = (vals: any[][]) =>\n  reduce((a: any[][], b: any[]) =>\n    flatMap(x => map(y => concat(x, [y]))(b))(a)\n  )([[]])(vals)\n\n// [[1,2], [3,4]]\n// [[]]\n// [[1,2]] , [[]] -> [[1,2], []]\n/*\nTurns seed data into node enriched data:\n  { foo: ['one', 'two']}\nbecomes\n  { foo: ['$choice$', ['one', 'two']]}\nbut if compiled data is input:\n  { foo: choice('one','two') } -> { foo: ['$choice$', ['one', 'two']]}\nit will return it as-is.\n\nThe goal is to separate a case when someone doesn't want a prop to be\nworked on.\n\nTo allow:\n\ndata  = {\n  foo: 'bar',\n  name: choice(1,2) // name is worked on\n}\n\nwhich is, behind the scenes, this:\n\ndata  = {\n  foo: 'bar',\n  name: ['$choice$', [1,2]]\n}\n\nNote: 'compile' detects if a '$choice$' marker exists _anywhere_\n      in data. if so, it will return data as-is.\n      otherwise, it assumes this structure:\n\n  data = {\n    foo: [1,2],\n    bar: [2,3]\n  }\n\n    and that the user wants all props to be worked on, so it compiles to:\n\n  data = {\n    foo: ['$choice$', [1,2]],\n    bar: ['$choice$', [2,3]]\n  }\n*/\nconst compile = <Props>(data: CartesianData<Props>) =>\n  find(v => isChoice(v), values(data))\n    ? data\n    : mapValues(v => (isArray(v) ? choice(...v) : v), data)\n\nconst isChoice = (v: any) =>\n  isArray(v) && v.length === 2 && first(v) === '$choice$'\nconst choice = (...choices: any) => ['$choice$', choices]\nconst nodeValue = (node: any) => get('1', node)\n\n/* \nSeed data structure:\n\nUse AST-like nodes to indicate choice fields, with which to\ndo cartesian operations.\n\nprops (sample data, type Props):\n{\n  prop1: 1,\n  prop2: 2\n}\n\ninput (sample data, type CartesianData<Props>):\n{\n  prop1: ['$choice$', [1,2,3]]  // will be used for cartesian data\n  prop2: [1,2,3]                // left as-is\n}\n\nWhere 'prop1', 'prop2' are fields that belong to Props type,\nCartesianData is typed to copy this field structure, and replace the\nvalues with _arrays of values_.\n*/\n\nconst defaultApply = <T>(\n  stories: any,\n  variants: Array<StoryVariant<T>>\n): void => {\n  each(cand => stories.add(cand.title, () => cand.story), variants)\n}\n\nconst alwaysValid = () => true\n\nconst cartesian = (stories: any) => ({\n  add: <Props>(\n    seed: () => CartesianData<Props>,\n    renderStory: (props: Props) => any,\n    opts: {\n      renderTitle?: (props: Props) => string\n      valid?: (props: Props) => boolean\n      apply?: (stories: any, variants: Array<StoryVariant<Props>>) => void\n    }\n  ) => {\n    const { valid, renderTitle, apply } = {\n      apply: defaultApply as (\n        stories: any,\n        variants: Array<StoryVariant<Props>>\n      ) => void,\n      renderTitle: (props: Props) => JSON.stringify(props),\n      valid: alwaysValid,\n      ...opts\n    }\n    // { foo: { bar: [1,2] } } -> { 'foo.bar': [1,2] }\n    const data = flatten(seed(), { safe: true })\n\n    // { 'foo.bar': [1,2] } -> { 'foo.bar': ['$choice$', [1,2]] }\n    const compiledData = compile(data)\n\n    // -> ['foo.bar']\n    const fields = keys(compiledData)\n\n    // { foo.bar: ['$choice$', [1,2]], bar.baz: ['$choice$', [3,4]]} -> [ [1,2] ] -> [1, 2]\n    // -> ['foo.bar', 'bar.baz']   xproduct [[1,2], [3,4]]\n    // -> ['foo.bar', 'bar.baz']        `-> [[1,3], [1,4], [2,3], [2,4]]\n    //                                ,---each---'\n    // -> ['foo.bar', 'bar.baz'] zip [1,3] -> [['foo.bar',1], ['bar.baz':3]]\n    //      ,------------------------------------'\n    // -> fromPairs -> {foo.bar: 1, bar.baz:3} -> unflatten -> {foo:{bar:1}, bar:{baz:3}}\n    // -> Array<Props> !\n    const rows = map(\n      p => unflatten(fromPairs(zip(fields, p))) as Props,\n      xproduct(\n        map(\n          v => (isChoice(v) ? nodeValue(v) : [v]),\n          values<CartesianData<Props>>(compiledData)\n        )\n      )\n    )\n\n    // filter rows (remove empty and nonvalid)\n    // per row, build a StoryVariant<Props> descriptor on which we call 'apply'.\n    // apply simply ships props, story, and title to storybook, with storybook\n    // specific glue, but because this is abstracted, can be done to anything that\n    // wants this story descriptor\n    const variants: Array<StoryVariant<Props>> = map(\n      props => ({\n        props,\n        story: renderStory(props),\n        title: renderTitle(props)\n      }),\n      filter(valid, filter(negate(isEmpty), rows))\n    )\n\n    // should do a foreach on the stories module (anything that supports 'add')\n    // per variants from variants\n    apply(stories, variants)\n  }\n})\n\nexport { choice, renderWithLegend, renderWithLegendFlat, xproduct, titles }\nexport default cartesian\n"],"names":["toPairs","keys","unflatten","mapValues","flatten","reduce","flatMap","map","concat","find","values","isArray","first","get","each","fromPairs","zip","filter","negate","isEmpty"],"mappings":"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"}